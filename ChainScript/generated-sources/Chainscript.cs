// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: chainscript.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Stratumn.Chainscript.Proto {

  /// <summary>Holder for reflection information generated from chainscript.proto</summary>
  public static partial class ChainscriptReflection {

    #region Descriptor
    /// <summary>File descriptor for chainscript.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ChainscriptReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFjaGFpbnNjcmlwdC5wcm90bxIUc3RyYXR1bW4uY2hhaW5zY3JpcHQiZAoH",
            "U2VnbWVudBIoCgRsaW5rGAEgASgLMhouc3RyYXR1bW4uY2hhaW5zY3JpcHQu",
            "TGluaxIvCgRtZXRhGAIgASgLMiEuc3RyYXR1bW4uY2hhaW5zY3JpcHQuU2Vn",
            "bWVudE1ldGEiUwoLU2VnbWVudE1ldGESEQoJbGlua19oYXNoGAEgASgMEjEK",
            "CWV2aWRlbmNlcxgKIAMoCzIeLnN0cmF0dW1uLmNoYWluc2NyaXB0LkV2aWRl",
            "bmNlIk0KCEV2aWRlbmNlEg8KB3ZlcnNpb24YASABKAkSDwoHYmFja2VuZBgK",
            "IAEoCRIQCghwcm92aWRlchgLIAEoCRINCgVwcm9vZhgUIAEoDCKIAQoETGlu",
            "axIPCgd2ZXJzaW9uGAEgASgJEgwKBGRhdGEYCiABKAwSLAoEbWV0YRgLIAEo",
            "CzIeLnN0cmF0dW1uLmNoYWluc2NyaXB0LkxpbmtNZXRhEjMKCnNpZ25hdHVy",
            "ZXMYFCADKAsyHy5zdHJhdHVtbi5jaGFpbnNjcmlwdC5TaWduYXR1cmUiJgoH",
            "UHJvY2VzcxIMCgRuYW1lGAEgASgJEg0KBXN0YXRlGAogASgJIogCCghMaW5r",
            "TWV0YRIRCgljbGllbnRfaWQYASABKAkSFgoOcHJldl9saW5rX2hhc2gYCiAB",
            "KAwSEAoIcHJpb3JpdHkYCyABKAESMQoEcmVmcxgMIAMoCzIjLnN0cmF0dW1u",
            "LmNoYWluc2NyaXB0LkxpbmtSZWZlcmVuY2USEgoKb3V0X2RlZ3JlZRgNIAEo",
            "BRIuCgdwcm9jZXNzGBQgASgLMh0uc3RyYXR1bW4uY2hhaW5zY3JpcHQuUHJv",
            "Y2VzcxIOCgZtYXBfaWQYFSABKAkSDgoGYWN0aW9uGB4gASgJEgwKBHN0ZXAY",
            "HyABKAkSDAoEdGFncxggIAMoCRIMCgRkYXRhGGQgASgMIjMKDUxpbmtSZWZl",
            "cmVuY2USEQoJbGlua19oYXNoGAEgASgMEg8KB3Byb2Nlc3MYCiABKAkiZwoJ",
            "U2lnbmF0dXJlEg8KB3ZlcnNpb24YASABKAkSDAoEdHlwZRgCIAEoCRIUCgxw",
            "YXlsb2FkX3BhdGgYCiABKAkSEgoKcHVibGljX2tleRgUIAEoDBIRCglzaWdu",
            "YXR1cmUYFSABKAxCTQoUc3RyYXR1bW4uY2hhaW5zY3JpcHRCC0NoYWluc2Ny",
            "aXB0WgtjaGFpbnNjcmlwdKoCGlN0cmF0dW1uLkNoYWluc2NyaXB0LlByb3Rv",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.Segment), global::Stratumn.Chainscript.Proto.Segment.Parser, new[]{ "Link", "Meta" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.SegmentMeta), global::Stratumn.Chainscript.Proto.SegmentMeta.Parser, new[]{ "LinkHash", "Evidences" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.Evidence), global::Stratumn.Chainscript.Proto.Evidence.Parser, new[]{ "Version", "Backend", "Provider", "Proof" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.Link), global::Stratumn.Chainscript.Proto.Link.Parser, new[]{ "Version", "Data", "Meta", "Signatures" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.Process), global::Stratumn.Chainscript.Proto.Process.Parser, new[]{ "Name", "State" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.LinkMeta), global::Stratumn.Chainscript.Proto.LinkMeta.Parser, new[]{ "ClientId", "PrevLinkHash", "Priority", "Refs", "OutDegree", "Process", "MapId", "Action", "Step", "Tags", "Data" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.LinkReference), global::Stratumn.Chainscript.Proto.LinkReference.Parser, new[]{ "LinkHash", "Process" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Stratumn.Chainscript.Proto.Signature), global::Stratumn.Chainscript.Proto.Signature.Parser, new[]{ "Version", "Type", "PayloadPath", "PublicKey", "Signature_" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A segment describes an atomic step in your process.
  /// </summary>
  public sealed partial class Segment : pb::IMessage<Segment> {
    private static readonly pb::MessageParser<Segment> _parser = new pb::MessageParser<Segment>(() => new Segment());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Segment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Segment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Segment(Segment other) : this() {
      link_ = other.link_ != null ? other.link_.Clone() : null;
      meta_ = other.meta_ != null ? other.meta_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Segment Clone() {
      return new Segment(this);
    }

    /// <summary>Field number for the "link" field.</summary>
    public const int LinkFieldNumber = 1;
    private global::Stratumn.Chainscript.Proto.Link link_;
    /// <summary>
    /// The link is the immutable part of a segment.
    /// It contains the details of the step.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Stratumn.Chainscript.Proto.Link Link {
      get { return link_; }
      set {
        link_ = value;
      }
    }

    /// <summary>Field number for the "meta" field.</summary>
    public const int MetaFieldNumber = 2;
    private global::Stratumn.Chainscript.Proto.SegmentMeta meta_;
    /// <summary>
    /// The link can be enriched with potentially mutable metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Stratumn.Chainscript.Proto.SegmentMeta Meta {
      get { return meta_; }
      set {
        meta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Segment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Segment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Link, other.Link)) return false;
      if (!object.Equals(Meta, other.Meta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (link_ != null) hash ^= Link.GetHashCode();
      if (meta_ != null) hash ^= Meta.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (link_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Link);
      }
      if (meta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Meta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (link_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Link);
      }
      if (meta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Meta);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Segment other) {
      if (other == null) {
        return;
      }
      if (other.link_ != null) {
        if (link_ == null) {
          Link = new global::Stratumn.Chainscript.Proto.Link();
        }
        Link.MergeFrom(other.Link);
      }
      if (other.meta_ != null) {
        if (meta_ == null) {
          Meta = new global::Stratumn.Chainscript.Proto.SegmentMeta();
        }
        Meta.MergeFrom(other.Meta);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (link_ == null) {
              Link = new global::Stratumn.Chainscript.Proto.Link();
            }
            input.ReadMessage(Link);
            break;
          }
          case 18: {
            if (meta_ == null) {
              Meta = new global::Stratumn.Chainscript.Proto.SegmentMeta();
            }
            input.ReadMessage(Meta);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Segment metadata. This is the potentially mutable part of a segment.
  /// It contains some invariants (hash of the immutable link) and evidences
  /// for the link that can be produced after the link is created.
  /// </summary>
  public sealed partial class SegmentMeta : pb::IMessage<SegmentMeta> {
    private static readonly pb::MessageParser<SegmentMeta> _parser = new pb::MessageParser<SegmentMeta>(() => new SegmentMeta());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SegmentMeta> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SegmentMeta() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SegmentMeta(SegmentMeta other) : this() {
      linkHash_ = other.linkHash_;
      evidences_ = other.evidences_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SegmentMeta Clone() {
      return new SegmentMeta(this);
    }

    /// <summary>Field number for the "link_hash" field.</summary>
    public const int LinkHashFieldNumber = 1;
    private pb::ByteString linkHash_ = pb::ByteString.Empty;
    /// <summary>
    /// Hash of the segment's link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString LinkHash {
      get { return linkHash_; }
      set {
        linkHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "evidences" field.</summary>
    public const int EvidencesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Stratumn.Chainscript.Proto.Evidence> _repeated_evidences_codec
        = pb::FieldCodec.ForMessage(82, global::Stratumn.Chainscript.Proto.Evidence.Parser);
    private readonly pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Evidence> evidences_ = new pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Evidence>();
    /// <summary>
    /// Evidences produced for the segment's link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Evidence> Evidences {
      get { return evidences_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SegmentMeta);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SegmentMeta other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LinkHash != other.LinkHash) return false;
      if(!evidences_.Equals(other.evidences_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LinkHash.Length != 0) hash ^= LinkHash.GetHashCode();
      hash ^= evidences_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LinkHash.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(LinkHash);
      }
      evidences_.WriteTo(output, _repeated_evidences_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LinkHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(LinkHash);
      }
      size += evidences_.CalculateSize(_repeated_evidences_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SegmentMeta other) {
      if (other == null) {
        return;
      }
      if (other.LinkHash.Length != 0) {
        LinkHash = other.LinkHash;
      }
      evidences_.Add(other.evidences_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LinkHash = input.ReadBytes();
            break;
          }
          case 82: {
            evidences_.AddEntriesFrom(input, _repeated_evidences_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Evidences can be used to externally verify a link's existence at a given 
  /// moment in time.
  /// An evidence can be a proof of inclusion in a public blockchain, a timestamp
  /// signed by a trusted authority or anything that you trust to provide an 
  /// immutable ordering of your process' steps.
  /// </summary>
  public sealed partial class Evidence : pb::IMessage<Evidence> {
    private static readonly pb::MessageParser<Evidence> _parser = new pb::MessageParser<Evidence>(() => new Evidence());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Evidence> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evidence() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evidence(Evidence other) : this() {
      version_ = other.version_;
      backend_ = other.backend_;
      provider_ = other.provider_;
      proof_ = other.proof_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evidence Clone() {
      return new Evidence(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private string version_ = "";
    /// <summary>
    /// Version of the evidence format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "backend" field.</summary>
    public const int BackendFieldNumber = 10;
    private string backend_ = "";
    /// <summary>
    /// Identifier of the evidence type.
    /// For example, in the case of a timestamp on the Bitcoin blockchain,
    /// this would be "bitcoin".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Backend {
      get { return backend_; }
      set {
        backend_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "provider" field.</summary>
    public const int ProviderFieldNumber = 11;
    private string provider_ = "";
    /// <summary>
    /// Instance of the backend used.
    /// For example, in the case of a timestamp on the Bitcoin blockchain,
    /// this would be the chain ID (to identify testnet from mainnet).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Provider {
      get { return provider_; }
      set {
        provider_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "proof" field.</summary>
    public const int ProofFieldNumber = 20;
    private pb::ByteString proof_ = pb::ByteString.Empty;
    /// <summary>
    /// Data that should be usable offline by any client wishing to validate
    /// the evidence.
    /// For backwards compatibility, you should update the evidence version 
    /// when the structure of this proof changes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Proof {
      get { return proof_; }
      set {
        proof_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Evidence);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Evidence other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (Backend != other.Backend) return false;
      if (Provider != other.Provider) return false;
      if (Proof != other.Proof) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (Backend.Length != 0) hash ^= Backend.GetHashCode();
      if (Provider.Length != 0) hash ^= Provider.GetHashCode();
      if (Proof.Length != 0) hash ^= Proof.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Version);
      }
      if (Backend.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Backend);
      }
      if (Provider.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(Provider);
      }
      if (Proof.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteBytes(Proof);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (Backend.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Backend);
      }
      if (Provider.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Provider);
      }
      if (Proof.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Proof);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Evidence other) {
      if (other == null) {
        return;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      if (other.Backend.Length != 0) {
        Backend = other.Backend;
      }
      if (other.Provider.Length != 0) {
        Provider = other.Provider;
      }
      if (other.Proof.Length != 0) {
        Proof = other.Proof;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Version = input.ReadString();
            break;
          }
          case 82: {
            Backend = input.ReadString();
            break;
          }
          case 90: {
            Provider = input.ReadString();
            break;
          }
          case 162: {
            Proof = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A link is the immutable part of a segment.
  /// A link contains all the data that represents a process' step.
  /// </summary>
  public sealed partial class Link : pb::IMessage<Link> {
    private static readonly pb::MessageParser<Link> _parser = new pb::MessageParser<Link>(() => new Link());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Link> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Link() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Link(Link other) : this() {
      version_ = other.version_;
      data_ = other.data_;
      meta_ = other.meta_ != null ? other.meta_.Clone() : null;
      signatures_ = other.signatures_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Link Clone() {
      return new Link(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private string version_ = "";
    /// <summary>
    /// Version of the link format.
    /// You can for example use the git tag of the code used to create the link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 10;
    private pb::ByteString data_ = pb::ByteString.Empty;
    /// <summary>
    /// Data representing the process' step details.
    /// For backwards compatibility, you should update the link version
    /// in meta when the structure/encoding of this field changes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Data {
      get { return data_; }
      set {
        data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meta" field.</summary>
    public const int MetaFieldNumber = 11;
    private global::Stratumn.Chainscript.Proto.LinkMeta meta_;
    /// <summary>
    /// Metadata associated to the process' step.
    /// Some of this metadata is used to provide filtering options when
    /// fetching links.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Stratumn.Chainscript.Proto.LinkMeta Meta {
      get { return meta_; }
      set {
        meta_ = value;
      }
    }

    /// <summary>Field number for the "signatures" field.</summary>
    public const int SignaturesFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Stratumn.Chainscript.Proto.Signature> _repeated_signatures_codec
        = pb::FieldCodec.ForMessage(162, global::Stratumn.Chainscript.Proto.Signature.Parser);
    private readonly pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Signature> signatures_ = new pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Signature>();
    /// <summary>
    /// (Optional) Signatures of configurable parts of the link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Stratumn.Chainscript.Proto.Signature> Signatures {
      get { return signatures_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Link);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Link other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (Data != other.Data) return false;
      if (!object.Equals(Meta, other.Meta)) return false;
      if(!signatures_.Equals(other.signatures_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (Data.Length != 0) hash ^= Data.GetHashCode();
      if (meta_ != null) hash ^= Meta.GetHashCode();
      hash ^= signatures_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Version);
      }
      if (Data.Length != 0) {
        output.WriteRawTag(82);
        output.WriteBytes(Data);
      }
      if (meta_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Meta);
      }
      signatures_.WriteTo(output, _repeated_signatures_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (Data.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
      }
      if (meta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Meta);
      }
      size += signatures_.CalculateSize(_repeated_signatures_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Link other) {
      if (other == null) {
        return;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      if (other.Data.Length != 0) {
        Data = other.Data;
      }
      if (other.meta_ != null) {
        if (meta_ == null) {
          Meta = new global::Stratumn.Chainscript.Proto.LinkMeta();
        }
        Meta.MergeFrom(other.Meta);
      }
      signatures_.Add(other.signatures_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Version = input.ReadString();
            break;
          }
          case 82: {
            Data = input.ReadBytes();
            break;
          }
          case 90: {
            if (meta_ == null) {
              Meta = new global::Stratumn.Chainscript.Proto.LinkMeta();
            }
            input.ReadMessage(Meta);
            break;
          }
          case 162: {
            signatures_.AddEntriesFrom(input, _repeated_signatures_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A process represents a real-world process that is shared between multiple
  /// independent actors.
  /// </summary>
  public sealed partial class Process : pb::IMessage<Process> {
    private static readonly pb::MessageParser<Process> _parser = new pb::MessageParser<Process>(() => new Process());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Process> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Process() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Process(Process other) : this() {
      name_ = other.name_;
      state_ = other.state_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Process Clone() {
      return new Process(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 10;
    private string state_ = "";
    /// <summary>
    /// The current state of the process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string State {
      get { return state_; }
      set {
        state_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Process);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Process other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (State != other.State) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (State.Length != 0) hash ^= State.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (State.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(State);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (State.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(State);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Process other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.State.Length != 0) {
        State = other.State;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 82: {
            State = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Metadata associated to a process' step.
  /// Once included in a segment, this is immutable.
  /// </summary>
  public sealed partial class LinkMeta : pb::IMessage<LinkMeta> {
    private static readonly pb::MessageParser<LinkMeta> _parser = new pb::MessageParser<LinkMeta>(() => new LinkMeta());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LinkMeta> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkMeta() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkMeta(LinkMeta other) : this() {
      clientId_ = other.clientId_;
      prevLinkHash_ = other.prevLinkHash_;
      priority_ = other.priority_;
      refs_ = other.refs_.Clone();
      outDegree_ = other.outDegree_;
      process_ = other.process_ != null ? other.process_.Clone() : null;
      mapId_ = other.mapId_;
      action_ = other.action_;
      step_ = other.step_;
      tags_ = other.tags_.Clone();
      data_ = other.data_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkMeta Clone() {
      return new LinkMeta(this);
    }

    /// <summary>Field number for the "client_id" field.</summary>
    public const int ClientIdFieldNumber = 1;
    private string clientId_ = "";
    /// <summary>
    /// The Client ID should be set by the client code creating the link.
    /// Use a unique ID that easily identifies your library, for example the
    /// github url of your repository.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClientId {
      get { return clientId_; }
      set {
        clientId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "prev_link_hash" field.</summary>
    public const int PrevLinkHashFieldNumber = 10;
    private pb::ByteString prevLinkHash_ = pb::ByteString.Empty;
    /// <summary>
    /// Hash of the previous link (in the same process).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString PrevLinkHash {
      get { return prevLinkHash_; }
      set {
        prevLinkHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 11;
    private double priority_;
    /// <summary>
    /// Priority of the link.
    /// Can be used to order and filter search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "refs" field.</summary>
    public const int RefsFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Stratumn.Chainscript.Proto.LinkReference> _repeated_refs_codec
        = pb::FieldCodec.ForMessage(98, global::Stratumn.Chainscript.Proto.LinkReference.Parser);
    private readonly pbc::RepeatedField<global::Stratumn.Chainscript.Proto.LinkReference> refs_ = new pbc::RepeatedField<global::Stratumn.Chainscript.Proto.LinkReference>();
    /// <summary>
    /// References to related links (potentially in other processes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Stratumn.Chainscript.Proto.LinkReference> Refs {
      get { return refs_; }
    }

    /// <summary>Field number for the "out_degree" field.</summary>
    public const int OutDegreeFieldNumber = 13;
    private int outDegree_;
    /// <summary>
    /// Maximum number of children the current link is allowed to have.
    /// A reference doesn't count as a child, only usage of prev_link_hash
    /// counts as a link child.
    /// It is the application's responsibility to comply with this property.
    /// If set to -1, the link can have as many children as it wants.
    /// If set to 0, the link can't have any children.
    /// If set to n > 0, the link can have at most n children.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int OutDegree {
      get { return outDegree_; }
      set {
        outDegree_ = value;
      }
    }

    /// <summary>Field number for the "process" field.</summary>
    public const int ProcessFieldNumber = 20;
    private global::Stratumn.Chainscript.Proto.Process process_;
    /// <summary>
    /// A link is a step in a given process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Stratumn.Chainscript.Proto.Process Process {
      get { return process_; }
      set {
        process_ = value;
      }
    }

    /// <summary>Field number for the "map_id" field.</summary>
    public const int MapIdFieldNumber = 21;
    private string mapId_ = "";
    /// <summary>
    /// A link always belongs to a specific map in that process.
    /// A map is an instance of a process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MapId {
      get { return mapId_; }
      set {
        mapId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 30;
    private string action_ = "";
    /// <summary>
    /// (Optional) Action in the process that resulted in the link's creation.
    /// Can be used to filter link search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Action {
      get { return action_; }
      set {
        action_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "step" field.</summary>
    public const int StepFieldNumber = 31;
    private string step_ = "";
    /// <summary>
    /// (Optional) Step of the process that results from the action.
    /// Can be used to help deserialize link data or filter link search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Step {
      get { return step_; }
      set {
        step_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 32;
    private static readonly pb::FieldCodec<string> _repeated_tags_codec
        = pb::FieldCodec.ForString(258);
    private readonly pbc::RepeatedField<string> tags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (Optional) Tags that can be used to filter link search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Tags {
      get { return tags_; }
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 100;
    private pb::ByteString data_ = pb::ByteString.Empty;
    /// <summary>
    /// (Optional) Additional metadata needed by your business logic.
    /// For backwards compatibility, you should update the link version when the
    /// structure of this field changes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Data {
      get { return data_; }
      set {
        data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LinkMeta);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LinkMeta other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClientId != other.ClientId) return false;
      if (PrevLinkHash != other.PrevLinkHash) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Priority, other.Priority)) return false;
      if(!refs_.Equals(other.refs_)) return false;
      if (OutDegree != other.OutDegree) return false;
      if (!object.Equals(Process, other.Process)) return false;
      if (MapId != other.MapId) return false;
      if (Action != other.Action) return false;
      if (Step != other.Step) return false;
      if(!tags_.Equals(other.tags_)) return false;
      if (Data != other.Data) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ClientId.Length != 0) hash ^= ClientId.GetHashCode();
      if (PrevLinkHash.Length != 0) hash ^= PrevLinkHash.GetHashCode();
      if (Priority != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Priority);
      hash ^= refs_.GetHashCode();
      if (OutDegree != 0) hash ^= OutDegree.GetHashCode();
      if (process_ != null) hash ^= Process.GetHashCode();
      if (MapId.Length != 0) hash ^= MapId.GetHashCode();
      if (Action.Length != 0) hash ^= Action.GetHashCode();
      if (Step.Length != 0) hash ^= Step.GetHashCode();
      hash ^= tags_.GetHashCode();
      if (Data.Length != 0) hash ^= Data.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ClientId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ClientId);
      }
      if (PrevLinkHash.Length != 0) {
        output.WriteRawTag(82);
        output.WriteBytes(PrevLinkHash);
      }
      if (Priority != 0D) {
        output.WriteRawTag(89);
        output.WriteDouble(Priority);
      }
      refs_.WriteTo(output, _repeated_refs_codec);
      if (OutDegree != 0) {
        output.WriteRawTag(104);
        output.WriteInt32(OutDegree);
      }
      if (process_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Process);
      }
      if (MapId.Length != 0) {
        output.WriteRawTag(170, 1);
        output.WriteString(MapId);
      }
      if (Action.Length != 0) {
        output.WriteRawTag(242, 1);
        output.WriteString(Action);
      }
      if (Step.Length != 0) {
        output.WriteRawTag(250, 1);
        output.WriteString(Step);
      }
      tags_.WriteTo(output, _repeated_tags_codec);
      if (Data.Length != 0) {
        output.WriteRawTag(162, 6);
        output.WriteBytes(Data);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ClientId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClientId);
      }
      if (PrevLinkHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PrevLinkHash);
      }
      if (Priority != 0D) {
        size += 1 + 8;
      }
      size += refs_.CalculateSize(_repeated_refs_codec);
      if (OutDegree != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(OutDegree);
      }
      if (process_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Process);
      }
      if (MapId.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MapId);
      }
      if (Action.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Action);
      }
      if (Step.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Step);
      }
      size += tags_.CalculateSize(_repeated_tags_codec);
      if (Data.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Data);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LinkMeta other) {
      if (other == null) {
        return;
      }
      if (other.ClientId.Length != 0) {
        ClientId = other.ClientId;
      }
      if (other.PrevLinkHash.Length != 0) {
        PrevLinkHash = other.PrevLinkHash;
      }
      if (other.Priority != 0D) {
        Priority = other.Priority;
      }
      refs_.Add(other.refs_);
      if (other.OutDegree != 0) {
        OutDegree = other.OutDegree;
      }
      if (other.process_ != null) {
        if (process_ == null) {
          Process = new global::Stratumn.Chainscript.Proto.Process();
        }
        Process.MergeFrom(other.Process);
      }
      if (other.MapId.Length != 0) {
        MapId = other.MapId;
      }
      if (other.Action.Length != 0) {
        Action = other.Action;
      }
      if (other.Step.Length != 0) {
        Step = other.Step;
      }
      tags_.Add(other.tags_);
      if (other.Data.Length != 0) {
        Data = other.Data;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ClientId = input.ReadString();
            break;
          }
          case 82: {
            PrevLinkHash = input.ReadBytes();
            break;
          }
          case 89: {
            Priority = input.ReadDouble();
            break;
          }
          case 98: {
            refs_.AddEntriesFrom(input, _repeated_refs_codec);
            break;
          }
          case 104: {
            OutDegree = input.ReadInt32();
            break;
          }
          case 162: {
            if (process_ == null) {
              Process = new global::Stratumn.Chainscript.Proto.Process();
            }
            input.ReadMessage(Process);
            break;
          }
          case 170: {
            MapId = input.ReadString();
            break;
          }
          case 242: {
            Action = input.ReadString();
            break;
          }
          case 250: {
            Step = input.ReadString();
            break;
          }
          case 258: {
            tags_.AddEntriesFrom(input, _repeated_tags_codec);
            break;
          }
          case 802: {
            Data = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A reference to a link that can be in another process.
  /// </summary>
  public sealed partial class LinkReference : pb::IMessage<LinkReference> {
    private static readonly pb::MessageParser<LinkReference> _parser = new pb::MessageParser<LinkReference>(() => new LinkReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LinkReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkReference(LinkReference other) : this() {
      linkHash_ = other.linkHash_;
      process_ = other.process_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LinkReference Clone() {
      return new LinkReference(this);
    }

    /// <summary>Field number for the "link_hash" field.</summary>
    public const int LinkHashFieldNumber = 1;
    private pb::ByteString linkHash_ = pb::ByteString.Empty;
    /// <summary>
    /// Hash of the referenced link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString LinkHash {
      get { return linkHash_; }
      set {
        linkHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "process" field.</summary>
    public const int ProcessFieldNumber = 10;
    private string process_ = "";
    /// <summary>
    /// Process containing the referenced link.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Process {
      get { return process_; }
      set {
        process_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LinkReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LinkReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LinkHash != other.LinkHash) return false;
      if (Process != other.Process) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LinkHash.Length != 0) hash ^= LinkHash.GetHashCode();
      if (Process.Length != 0) hash ^= Process.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LinkHash.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(LinkHash);
      }
      if (Process.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Process);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LinkHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(LinkHash);
      }
      if (Process.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Process);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LinkReference other) {
      if (other == null) {
        return;
      }
      if (other.LinkHash.Length != 0) {
        LinkHash = other.LinkHash;
      }
      if (other.Process.Length != 0) {
        Process = other.Process;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LinkHash = input.ReadBytes();
            break;
          }
          case 82: {
            Process = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A signature of configurable parts of a link.
  /// Different signature types and versions are allowed to sign different 
  /// encodings of the data, but we recommend signing a hash of the 
  /// protobuf-encoded bytes.
  /// </summary>
  public sealed partial class Signature : pb::IMessage<Signature> {
    private static readonly pb::MessageParser<Signature> _parser = new pb::MessageParser<Signature>(() => new Signature());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Signature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Stratumn.Chainscript.Proto.ChainscriptReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signature(Signature other) : this() {
      version_ = other.version_;
      type_ = other.type_;
      payloadPath_ = other.payloadPath_;
      publicKey_ = other.publicKey_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signature Clone() {
      return new Signature(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private string version_ = "";
    /// <summary>
    /// Version of the signature format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private string type_ = "";
    /// <summary>
    /// Signature algorithm used (for example, "EdDSA").
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "payload_path" field.</summary>
    public const int PayloadPathFieldNumber = 10;
    private string payloadPath_ = "";
    /// <summary>
    /// A description of the parts of the links that are signed.
    /// This should unambiguously let the verifier recompute the signed payload
    /// bytes from the link's content.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PayloadPath {
      get { return payloadPath_; }
      set {
        payloadPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 20;
    private pb::ByteString publicKey_ = pb::ByteString.Empty;
    /// <summary>
    /// Encoded signer's public key.
    /// For backwards compatibility, you should update the signature version
    /// or the signature type when changing the encoding used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int Signature_FieldNumber = 21;
    private pb::ByteString signature_ = pb::ByteString.Empty;
    /// <summary>
    /// Signature bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Signature_ {
      get { return signature_; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Signature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Signature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (Type != other.Type) return false;
      if (PayloadPath != other.PayloadPath) return false;
      if (PublicKey != other.PublicKey) return false;
      if (Signature_ != other.Signature_) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (Type.Length != 0) hash ^= Type.GetHashCode();
      if (PayloadPath.Length != 0) hash ^= PayloadPath.GetHashCode();
      if (PublicKey.Length != 0) hash ^= PublicKey.GetHashCode();
      if (Signature_.Length != 0) hash ^= Signature_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Version);
      }
      if (Type.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (PayloadPath.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(PayloadPath);
      }
      if (PublicKey.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteBytes(PublicKey);
      }
      if (Signature_.Length != 0) {
        output.WriteRawTag(170, 1);
        output.WriteBytes(Signature_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (Type.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (PayloadPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PayloadPath);
      }
      if (PublicKey.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
      }
      if (Signature_.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Signature_);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Signature other) {
      if (other == null) {
        return;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      if (other.Type.Length != 0) {
        Type = other.Type;
      }
      if (other.PayloadPath.Length != 0) {
        PayloadPath = other.PayloadPath;
      }
      if (other.PublicKey.Length != 0) {
        PublicKey = other.PublicKey;
      }
      if (other.Signature_.Length != 0) {
        Signature_ = other.Signature_;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Version = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
          case 82: {
            PayloadPath = input.ReadString();
            break;
          }
          case 162: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 170: {
            Signature_ = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
